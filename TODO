* Allow setting tcp heartbeat
* Make sure we choose the ip address at random (if the host resolves to multiple servers)
* Error handing / monitors

* Enable / Allow publisher confirms (Confirm.Select) per channel
  - A publisher would wait for the next ack.
  - Keep track of all messages in a window of send, but not yet ack'ed messages
  - Discard returned messages

* Handle immediate flag in publish
  (Return messages - requires an async handler)

* Handle flow on channels

* Support immutable strings

* Setup RCP to cancel on message timeout
  - Add a header for return path (reply-to)
  - Setup the rpc server x-dead-letter-exchange to be amq.header
  - Bind the reply queue to amq.header when the reply-to header is ours.


API:
  avoid "type host = string".
  Move internal function to Internal modules
  Channel.unique_id public?
  Split prefetch into two functions (Global or non global)
  Only use Async.Std.Deferred.t
  Use opens and module aliases
  Remove label for exhange type
  Dont reference amqp_type from high level mli.
  Think about tristate ack functions
  (Exclusing and autodelete using shadow types)
  Queue get should return a value, not given a handler. Figure out how to handle ack.

  How to nack a message
  Rcp.client -> exchange
  Client call return a polymophic variant - Return a option type instead.

  Rpc.Server.start lacks functionality

Reorder:
  Amqp_types for global types only
